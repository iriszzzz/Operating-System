#!/usr/bin/env python3

import re 
from gradelib import *
from collections import defaultdict


import os

ART_DIR = "artifacts"; os.makedirs(ART_DIR, exist_ok=True)

def run_and_save(name, cmd):
    r.run_qemu(shell_script([cmd]))
    out = r.qemu.output
    with open(os.path.join(ART_DIR, f"{name}.log"), "w") as f:
        f.write(out)
    return out



workload = None
# r = Runner(save("xv6.out"))


def parse(outputs: str):
    """
    Parse the output of the xv6 scheduler tests.
    """
    results = {
        "pid": {},
        "ticks": {},
        "procstatelog": [],
    }
    lines = outputs.splitlines()
    for line in lines:
        match = re.search(
            r"procstatelog: pid=(\d+), ticks=(\d+), state=\"(\w+)\", priority=(\d+)",
            line,
        )
        if match:
            pid = int(match.group(1))
            ticks = int(match.group(2))
            state = match.group(3)
            priority = int(match.group(4))
            data = {
                "pid": pid,
                "ticks": ticks,
                "state": state,
                "priority": priority,
            }
            results["procstatelog"].append(data)
            if pid not in results["pid"]:
                results["pid"][pid] = {"procstatelog": []}
            results["pid"][pid]["procstatelog"].append(data)
            if ticks not in results["ticks"]:
                results["ticks"][ticks] = {"procstatelog": []}
            results["ticks"][ticks]["procstatelog"].append(data)
    return results


@test(0, "benchmark")
def test_benchmark():
    r.run_qemu(shell_script(["mp2-benchmark"]))
    outputs = r.qemu.output
    match = re.search(
        r"proclog: pid=(\d+), ticks=(\d+), tag=(\d+), state=\"(\w+)\", priority=(\d+)",
        outputs,
    )
    global workload
    if match:
        workload = int(match.group(3))
    else:
        workload = None

def pick_two_children(parsed):
    seen = []
    for e in parsed["procstatelog"]:
        if e["state"] == "new":
            if e["pid"] not in seen:
                seen.append(e["pid"])
            if len(seen) == 2:
                break
    assert len(seen) == 2, f"Need 2 children, got {seen}"
    return seen[0], seen[1]

@test(10, "l1-preempt-no-waiting", parent=test_benchmark)
def test_l1_preempt_no_waiting():
    outputs = run_and_save("l1-preempt-no-waiting", f"mp2-psjf-top {workload}")
    parsed = parse(outputs)
    A, B = pick_two_children(parsed)

    # 我們要找「某一次」B 變 running 的瞬間，A 恰好是從 running→ready（且不是 waiting）
    last_state = {}       # pid -> last state
    last_tick  = {}       # pid -> last tick
    preempt_found = False

    for e in parsed["procstatelog"]:
        pid, state, t = e["pid"], e["state"], e["ticks"]

        # 記錄狀態演進（只需要 A/B）
        if pid in (A, B):
            prev = last_state.get(pid)
            last_state[pid] = state
            last_tick[pid] = t

        # 當 B 變成 running，檢查是否是一次「搶佔」而非 A 自願 sleep
        if pid == B and state == "running":
            # A 的前一狀態要是 running，且 A 此刻（或同 tick）剛轉成 ready（不是 waiting）
            a_prev = last_state.get(A)         # 這是 A 的「目前」狀態
            a_prev_tick = last_tick.get(A)

            # 我們需要知道 A 在此之前的上一個狀態是什麼，因此再往前掃一個
            # 掃描到目前事件為止，回看 A 最近一次狀態變化
            a_prevprev = None
            for e2 in reversed(parsed["procstatelog"]):
                if e2["ticks"] > t: 
                    continue
                if e2["pid"] == A:
                    if a_prevprev is None:
                        a_prevprev = e2["state"]  # 這是 A 在 t 時的狀態
                        a_prevprev_tick = e2["ticks"]
                    else:
                        a_prevprev2 = e2["state"] # 這是 A 在 t 前一個狀態
                        a_prevprev2_tick = e2["ticks"]
                        # 我們只需要最近兩個狀態點
                        # 期望：a_prevprev2 == "running", a_prevprev == "ready", 且 a_prevprev_tick == t 或 t-1
                        if (a_prevprev == "ready" and a_prevprev2 == "running" 
                            and abs(a_prevprev_tick - t) <= 1):
                            preempt_found = True
                        break
            if preempt_found:
                break

    assert preempt_found, (
        f"No L1 preemption detected. See artifacts/l1-preempt-no-waiting.log "
        f"and verify an event where A: running→ready and immediately B: running."
    )



run_tests()
